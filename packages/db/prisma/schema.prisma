generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]

}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [vector]

}

model Account {
  id                       String   @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?  @db.Text
  refresh_token_expires_in Int?
  access_token             String?  @db.Text
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?  @db.Text
  session_state            String?
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id                String               @id @default(cuid())
  name              String?              /// @encrypted
  email             String?              @unique /// @encrypted
  emailHash         String?              @unique /// @encryption:hash(email)
  emailVerified     DateTime?
  image             String?
  hasOnboarded      Boolean              @default(false)
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  role              Role                 @default(USER)
  preferredLanguage String?              @default("en")
  receiveUpdates    Boolean              @default(false)
  isCompanyUser     Boolean              @default(false)
  isBanned          Boolean              @default(false)

  bans            Ban[]
  performedBans   Ban[] @relation("performedBans")
  performedUnbans Ban[] @relation("performedUnbans")

  accounts         Account[]
  sessions         Session[]
  subscription     Subscription?
  featureTemplates FeatureTemplate[]
}

model Ban {
  id               String  @id @default(cuid())
  userId           String
  bannedByUserId   String?
  unbannedByUserId String?
  banReason        String
  unbanReason      String?

  unbannedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  user       User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  bannedBy   User? @relation("performedBans", fields: [bannedByUserId], references: [id], onDelete: SetNull)
  unbannedBy User? @relation("performedUnbans", fields: [unbannedByUserId], references: [id], onDelete: SetNull)
}

model Subscription {
  customerId            String              @id
  subscriptionId        String?             @unique
  lookupKey             String?
  status                SubscriptionStatus?
  isCanceledAtPeriodEnd Boolean             @default(false)
  billingInterval       BillingInterval?

  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?

  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model WaitlistEntry {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String
  waitlistType String // e.g., "standard", "enterprise", "beta"
  status       String   @default("active") // For future use: "active", "contacted", "converted"
  source       String? // Optional: track where the signup came from
  referralCode String? // Optional: for referral tracking
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  metadata     Json? // Flexible field for additional data
  notes        String? // Admin notes

  @@index([waitlistType])
  @@index([createdAt])
  @@index([status])
}

model Ai_api_calls {
  id                  String   @id
  userId              String
  provider            String
  model               String
  prompt_string       String
  prompt_tokens       Int
  completion_tokens   Int
  total_tokens        Int
  responseData        String
  response_time       String
  status_code         Int
  usage_cost          Float
  createdAt           DateTime @default(now())
  audio_length_mins   Float?
  ai_response_words   Int?
  ai_response_chars   Int?
  prompt_number_words Int?
  prompt_number_chars Int?
}

model QueueTask {
  id              String      @id @default(cuid())
  type            String
  data            Json
  result          Json?
  status          QueueStatus @default(PENDING)
  attempts        Int         @default(0)
  maxAttempts     Int         @default(3)
  failedProviders String[]
  errorMessage    String?
  errorPatterns   Json?
  priority        Int         @default(0)
  scheduledFor    DateTime?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  processedAt     DateTime?

  // Generic reference fields
  referenceId    String? // ID of the related entity
  referenceModel String? // Name of the related model (e.g., "Story", "Video", "Audio")

  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@index([priority])
  @@index([scheduledFor])
  @@index([referenceId])
  @@index([referenceModel])
}

enum Role {
  USER 
  ADMIN 
  SUPER_ADMIN 
}

enum SubscriptionStatus {
  active
  canceled
  incomplete
  incomplete_expired
  past_due
  paused
  trialing
  unpaid
  expired
}

enum BillingInterval {
  day
  week
  month
  year
}

enum QueueStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  MAX_RETRIES_REACHED
}

// For newsletter subscribers
model NewsletterSubscriber {
  id               String   @id @default(cuid())
  email            String   @unique
  name             String?
  metadata         Json?
  subscribedAt     DateTime @default(now())
  isActive         Boolean  @default(true)
  source           String?
  tags             String[]
  updatedAt        DateTime @updatedAt
  unsubscribeToken String?  @unique

  @@index([subscribedAt])
  @@index([isActive])
}

// For general lead capture across multiple services
model Lead {
  id         String     @id @default(cuid())
  email      String
  name       String?
  phone      String?
  company    String?
  message    String? // Free-form message
  leadType   String // Flexible string for lead type
  status     LeadStatus @default(NEW)
  source     String? // Where the lead came from
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  metadata   Json? // Additional fields based on lead type
  assignedTo String? // User ID for assigned team member

  // Survey-related fields
  lastSurveyOfferedAt   DateTime?
  lastSurveyCompletedAt DateTime?

  // Relationships
  surveyResponses SurveyResponse[]

  @@index([leadType])
  @@index([status])
  @@index([createdAt])
  @@index([assignedTo])
  @@index([email])
}

// Feature Template model
model FeatureTemplate {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

// Lead status enum
enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  CONVERTED
  LOST
}

// Survey status enum
enum SurveyStatus {
  DRAFT
  PUBLISHED
  CLOSED
}

// Survey trigger type enum - when to present the survey
enum SurveyTriggerType {
  IMMEDIATE // Show immediately after lead submission
  DELAYED // Show after a delay
  MANUAL // Require manual triggering
}

// Survey definition model
model Survey {
  id          String       @id @default(cuid())
  title       String
  description String?
  status      SurveyStatus @default(DRAFT)
  surveyJson  Json // SurveyJS schema definition
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  createdBy   String? // User ID reference
  isArchived  Boolean      @default(false)

  // Configuration options
  redirectUrl     String? // URL to redirect to after completion
  thankYouMessage String? // Message to show after completion
  primaryColor    String? // Brand color for survey
  isPublic        Boolean @default(false) // Whether survey is publicly accessible

  // Relationships
  responses             SurveyResponse[]
  surveyLeadConnections SurveyLeadConnection[]

  @@index([status])
  @@index([createdAt])
  @@index([isArchived])
}

// Survey response model - stores individual response submissions
model SurveyResponse {
  id           String    @id @default(cuid())
  surveyId     String
  responseJson Json // Stores the actual response data
  startedAt    DateTime  @default(now())
  completedAt  DateTime?
  isCompleted  Boolean   @default(false)
  userId       String? // Optional User ID if authenticated
  leadId       String? // Optional Lead ID if connected to a lead
  ipAddress    String? // For tracking/analytics
  userAgent    String? // Browser/device info

  // Relationships
  survey Survey @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  lead   Lead?  @relation(fields: [leadId], references: [id], onDelete: SetNull)

  @@index([surveyId])
  @@index([leadId])
  @@index([completedAt])
  @@index([isCompleted])
}

// Connects surveys to leads - defines which leads should receive which surveys
model SurveyLeadConnection {
  id             String   @id @default(cuid())
  surveyId       String
  leadTypeFilter String? // Filter for lead types eligible for this survey
  isActive       Boolean  @default(true)
  priority       Int      @default(0) // Higher number = higher priority
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Connection settings
  triggerType  SurveyTriggerType @default(IMMEDIATE)
  delayMinutes Int? // For DELAYED trigger type

  // Relationships
  survey Survey @relation(fields: [surveyId], references: [id], onDelete: Cascade)

  @@index([surveyId])
  @@index([isActive])
  @@index([priority])
  @@index([leadTypeFilter])
}




model Resource {
  id        String      @id @default(cuid())
  content   String
  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime    @default(now()) @map("updated_at")
  embeddings Embedding[]

  @@map("resources")
}

model Embedding {
  id         String   @id @default(cuid())
  resourceId String   @map("resource_id")
  content    String
  embedding  Unsupported("vector(1536)")

  resource   Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)

  @@map("embeddings")
  // Prisma doesn't directly support HNSW indexes - you'll need to create this with raw SQL
  // CREATE EXTENSION IF NOT EXISTS vector;
  // CREATE INDEX ON embeddings USING hnsw (embedding vector_cosine_ops);
}

// Dealership/Company information
model Dealership {
  id              String   @id @default(cuid())
  name            String
  slug            String   @unique
  address         String?
  phone           String?
  website         String?
  email           String?
  
  // Business details
  businessType    String   @default("DEALER") // DEALER, PRIVATE_SELLER, AUCTION, RENTAL_COMPANY, FLEET, etc.
  isActive        Boolean  @default(true)
  
  // Branding
  logoUrl         String?
  primaryColor    String?
  secondaryColor  String?
  
  // Metadata
  metadata        Json?    // Flexible field for additional dealer-specific data
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  inventory       Inventory[]
  
  @@index([slug])
  @@index([businessType])
  @@index([isActive])
  @@index([createdAt])
}

// Core inventory
model Inventory {
  id              String   @id @default(cuid())
  
  // Core identifiers (indexed for fast queries)
  dealershipId    String
  sourceUrl       String?  // Original URL from scraping
  vin             String?  // Vehicle Identification Number
  stockNumber     String?  // Dealer's internal stock number
  
  // Core vehicle information (normalized for fast filtering)
  make            String?  // Toyota, Ford, etc.
  model           String?  // Camry, F-150, etc.
  year            Int?     // 2024, 2023, etc.
  trim            String?  // LX, Sport, etc.
  
  // Pricing (stored as integers for precise calculations)
  priceAmount     Int?     // Price in cents (e.g., $50,000 = 5000000)
  priceCurrency   String   @default("USD")
  msrpAmount      Int?     // MSRP in cents
  
  // Key specifications (most commonly filtered fields)
  mileage         Int?     // Odometer reading
  condition       String   @default("UNKNOWN") // NEW, USED, CERTIFIED_PRE_OWNED, DAMAGED, SALVAGE, etc.
  fuelType        String   @default("UNKNOWN") // GASOLINE, DIESEL, HYBRID, ELECTRIC, PLUG_IN_HYBRID, etc.
  transmission    String   @default("UNKNOWN") // MANUAL, AUTOMATIC, CVT, SEMI_AUTOMATIC, etc.
  drivetrain      String   @default("UNKNOWN") // FWD, RWD, AWD, FOUR_WD, etc.
  bodyStyle       String   @default("UNKNOWN") // SEDAN, COUPE, HATCHBACK, WAGON, SUV, CROSSOVER, PICKUP, VAN, etc.
  
  // Engine details
  engineSize      Float?   // Engine displacement in liters
  engineCylinders Int?     // Number of cylinders
  horsepower      Int?     // Horsepower rating
  
  // Fuel economy
  mpgCity         Int?     // City MPG
  mpgHighway      Int?     // Highway MPG
  mpgCombined     Int?     // Combined MPG
  
  // Colors
  exteriorColor   String?
  interiorColor   String?
  
  // Status and availability
  status          String   @default("AVAILABLE") // AVAILABLE, SOLD, PENDING, RESERVED, UNAVAILABLE, ARCHIVED, etc.
  isActive        Boolean  @default(true)
  isFeatured      Boolean  @default(false)
  
  // Data source tracking
  scrapedAt       DateTime?
  lastUpdated     DateTime @default(now())
  
  // Flexible data storage for varying structures
  rawData         Json?    // Complete original scraped data
  processedData   Json?    // Cleaned and processed data
  
  // Structured JSON fields for maximum performance
  features        Json?    // Array of features: [{category, name, value, isHighlight}]
  specifications  Json?    // Array of specs: [{category, name, value, unit, numericValue}]
  images          Json?    // Array of images: [{url, type, isPrimary, thumbnailUrl, altText}]
  
  // SEO and display
  title           String?  // Display title
  description     String?  @db.Text // Long description
  slug            String?  // URL-friendly identifier
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  dealership      Dealership @relation(fields: [dealershipId], references: [id], onDelete: Cascade)
  
  // Composite indexes for common query patterns
  @@index([dealershipId, isActive, status])
  @@index([make, model, year])
  @@index([priceAmount, condition])
  @@index([year, mileage])
  @@index([fuelType, transmission])
  @@index([bodyStyle, drivetrain])
  @@index([condition, fuelType])
  @@index([status, isActive])
  @@index([createdAt, isActive])
  @@index([isFeatured, isActive])
  @@index([vin]) // Unique vehicle identification
  @@index([stockNumber, dealershipId])
  @@index([slug])
  @@index([scrapedAt])
  @@index([lastUpdated])
  
}